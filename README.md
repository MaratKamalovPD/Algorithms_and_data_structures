# Algorithms_and_data_structures
 Задания по курсу "Алгоритмы и структуры данных", Образовательный центр VK и МГТУ им. Баумана - Технопарк Программа по веб-разработке, 1 семестр


## Модуль 1

### Задача 1

Во всех задачах необходимо использование битовых операций
Использование арифметических операций запрещено
Входное число лежит в диапазоне 0..2^32 -1 и вводится в десятичном виде

*1.2 Вернуть значение бита в числе N по его номеру K*
Формат входных данных. Число N, номер бита K

### Задача 2.2

Дан массив целых чисел А[0..n-1].
Известно, что на интервале [0, m] значения массива строго возрастают, а на интервале [m, n-1] строго убывают. 
Найти m за O(log m). 

__Требования:__  Время работы O(log m).
Внимание! В этой задаче сначала нужно определить диапазон для бинарного поиска размером порядка m с помощью экспоненциального поиска, а потом уже в нем делать бинарный поиск.
2 ≤ n ≤ 10000.

### Задача 3.3

Реализовать очередь с помощью двух стеков.
Использовать стек, реализованный с помощью динамического буфера.
Обрабатывать команды push back и pop front.
В первой строке количество команд n. n ≤ 1000000.

Каждая команда задаётся как 2 целых числа: a b.

a = 2 - pop front
a = 3 - push back

Если дана команда pop front, то число b - ожидаемое значение. 
Если команда pop front вызвана для пустой структуры данных, то ожидается “-1”.

Требуется напечатать YES - если все ожидаемые значения совпали.
Иначе, если хотя бы одно ожидание не оправдалось, то напечатать NO.

### Задача 4

Требование для всех вариантов Задачи 4
Решение всех задач данного раздела предполагает использование кучи, реализованной в виде шаблонного класса.
Решение должно поддерживать передачу функции сравнения снаружи.
Куча должна быть динамической.

*4.2 Топ K пользователей из лога*
Имеется лог - файл, в котором хранятся пары для N пользователей(Идентификатор пользователя, посещаемость сайта).
Напишите программу, которая выбирает K пользователей, которые чаще других заходили на сайт, и выводит их в порядке возрастания посещаемости.Количество заходов и идентификаторы пользователей не повторяются.

__Требования:__ время работы O(N* logK), где N - кол - во пользователей. Ограничение на размер кучи O(K).

__Формат входных данных:__ Сначала вводятся N и K, затем пары(Идентификатор пользователя, посещаемость сайта)

### Задача 5

Во всех задачах данного раздела необходимо реализовать и использовать сортировку слиянием в виде шаблонной функции.
Решение должно поддерживать передачу функции сравнения снаружи.
Общее время работы алгоритма O(n log n)

*5_4.Закраска прямой 2.*
На числовой прямой окрасили N отрезков.
Известны координаты левого и правого концов каждого отрезка(Li и Ri).
Найти сумму длин частей числовой прямой, окрашенных ровно в один слой.

### Задача 6

Дано множество целых чисел из [0..10^9] размера n. 
Используя алгоритм поиска k - ой порядковой статистики, требуется найти следующие параметры множества :
* 10 % перцентиль
* медиана
* 90 % перцентиль

__Требования:__ 
К дополнительной памяти : O(n).
Среднее время работы : O(n)
Должна быть отдельно выделенная функция partition.
Рекурсия запрещена.
Решение должно поддерживать передачу функции сравнения снаружи.

Функцию Partition следует реализовывать методом прохода двумя итераторами в одном направлении.Описание для случая прохода от начала массива к концу :
Выбирается опорный элемент.Опорный элемент меняется с последним элементом массива.
Во время работы Partition в начале массива содержатся элементы, не бОльшие опорного.
Затем располагаются элементы, строго бОльшие опорного.В конце массива лежат нерассмотренные элементы.
Последним элементом лежит опорный.
Итератор(индекс) i указывает на начало группы элементов, строго бОльших опорного.
Итератор j больше i, итератор j указывает на первый нерассмотренный элемент.
Шаг алгоритма.Рассматривается элемент, на который указывает j.Если он больше опорного, то сдвигаем j.
Если он не больше опорного, то меняем a[i] и a[j] местами, сдвигаем i и сдвигаем j.
В конце работы алгоритма меняем опорный и элемент, на который указывает итератор i.

*Задача 6_3.*
Реализуйте стратегию выбора опорного элемента “случайный элемент”.
Функцию Partition реализуйте методом прохода двумя итераторами от начала массива к концу.

### Задача 7.1

MSD для строк.
Дан массив строк.Количество строк не больше 10^5.
Отсортировать массив методом поразрядной сортировки MSD по символам.
Размер алфавита - 256 символов.Последний символ строки = ‘\0’.


## Модуль 2

### Задача 1

Реализуйте структуру данных типа “множество строк” на основе динамической хеш - таблицы с открытой адресацией.
Хранимые строки непустые и состоят из строчных латинских букв.
Хеш - функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера.
Начальный размер таблицы должен быть равным 8 - ми.
Перехеширование выполняйте при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3 / 4.
Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.

*1_2. Для разрешения коллизий используйте двойное хеширование.*
Требования: В таблице запрещено хранение указателей на описатель элемента.

__Формат входных данных:__
Каждая строка входных данных задает одну операцию над множеством.
Запись операции состоит из типа операции и следующей за ним через пробел строки, над которой проводится операция.
Тип операции  – один из трех символов :
+означает добавление данной строки в множество;
-означает удаление  строки из множества;
?означает проверку принадлежности данной строки множеству.
При добавлении элемента в множество НЕ ГАРАНТИРУЕТСЯ, что он отсутствует в этом множестве.
При удалении элемента из множества НЕ ГАРАНТИРУЕТСЯ, что он присутствует в этом множестве.

__Формат выходных данных:__
Программа должна вывести для каждой операции одну из двух строк OK или FAIL, в зависимости от того, встречается ли данное слово в нашем множестве.

### Задача 2

Дано число N < 10^6 и последовательность целых чисел из (-2^31..2^31) длиной N.
Требуется построить бинарное дерево, заданное наивным порядком вставки.
Т.е., при добавлении очередного числа K в дерево с корнем root, если root→Key ≤ K, то узел K добавляется в правое поддерево root; иначе в левое поддерево root.
Требования: Рекурсия запрещена.Решение должно поддерживать передачу функции сравнения снаружи.

*2_4.Выведите элементы в порядке level - order(по слоям, “в ширину”).*

### Задача 3

**B-дерево**
Постройте B - дерево минимального порядка t и выведите его по слоям.
В качестве ключа используются числа, лежащие в диапазоне[0..23^2 - 1]

__Требования:__
B - дерево должно быть реализовано в виде шаблонного класса.
Решение должно поддерживать передачу функции сравнения снаружи.

__Формат ввода__
Сначала вводится минимальный порядок дерева t.
Затем вводятся элементы дерева.

__Формат вывода__
Программа должна вывести B - дерево по слоям.
Каждый слой на новой строке, элементы должны выводится в том порядке, в котором они лежат в узлах.

### Задача 4

**Задача 4.1**
В одной военной части решили построить в одну шеренгу по росту.
Т.к. часть была далеко не образцовая, то солдаты часто приходили не вовремя, а то их и вовсе приходилось выгонять из шеренги за плохо начищенные сапоги. 
Однако солдаты в процессе прихода и ухода должны были всегда быть выстроены по росту – сначала самые высокие, а в конце – самые низкие.
За расстановку солдат отвечал прапорщик, который заметил интересную особенность – все солдаты в части разного роста.
Ваша задача состоит в том, чтобы помочь прапорщику правильно расставлять солдат, а именно для каждого приходящего солдата указывать, перед каким солдатом в строе он должен становится.
Требуемая скорость выполнения команды - O(log n).

__Формат ввода__
Первая строка содержит число N – количество команд(1 ≤ N ≤ 90 000).В каждой следующей строке содержится описание команды : число 1 и X если солдат приходит в строй(X – рост солдата, натуральное число до 100 000 включительно) и число 2 и Y если солдата, стоящим в строе на месте Y надо удалить из строя.Солдаты в строе нумеруются с нуля.

__Формат вывода__
На каждую команду 1 (добавление в строй) вы должны выводить число K – номер позиции, на которую должен встать этот солдат(все стоящие за ним двигаются назад).


## Модуль 3

### Задача: 1. Представление графа

Дан базовый интерфейс для представления ориентированного графа:
```
struct IGraph {
    virtual ~IGraph() {}
	
    // Добавление ребра от from к to.
    virtual void AddEdge(int from, int to) = 0;

    virtual int VerticesCount() const  = 0;

    virtual std::vector<int> GetNextVertices(int vertex) const = 0;
    virtual std::vector<int> GetPrevVertices(int vertex) const = 0;
};
```

Необходимо написать несколько реализаций интерфейса:
* ListGraph, хранящий граф в виде массива списков смежности,
* MatrixGraph, хранящий граф в виде матрицы смежности,
* SetGraph, хранящий граф в виде массива хэш-таблиц/сбалансированных деревьев поиска,
* ArcGraph, хранящий граф в виде одного массива пар {from, to}.

Также необходимо реализовать конструктор, принимающий const IGraph&. Такой конструктор должен скопировать переданный граф в создаваемый объект.
Для каждого класса создавайте отдельные h и cpp файлы.
Число вершин графа задается в конструкторе каждой реализации.


### Задача: 2. Количество различных путей
 Дан невзвешенный неориентированный граф.
 В графе может быть несколько кратчайших путей между какими - то вершинами.
 Найдите количество различных кратчайших путей между заданными вершинами.
 Требования: сложность O(V + E).
 __Формат ввода.__
 v : кол - во вершин(макс. 50000),
 n : кол - во ребер(макс. 200000),
 n пар реберных вершин,
 пара вершин u, w для запроса.
 __Формат вывода.__
 Количество кратчайших путей от u к w.

### Задача: 3. Города
 Требуется отыскать самый выгодный маршрут между городами.
 Требования: время работы O((N + M)logN), где N - количество городов, M - известных дорог между ними.
 __Формат входных данных.__
 Первая строка содержит число N – количество городов.
 Вторая строка содержит число M - количество дорог.
 Каждая следующая строка содержит описание дороги(откуда, куда, время в пути).
 Последняя строка содержит маршрут(откуда и куда нужно доехать).
 __Формат выходных данных.__
 Вывести длину самого выгодного маршрута

### Задача 4

### Задача 5
 Найдите приближенное решение метрической неориентированной задачи коммивояжера в полном графе(на плоскости) с помощью минимального остовного дерева.
 Оцените качество приближения на случайном наборе точек, нормально распределенном на плоскости с дисперсией 1. 
 Нормально распределенный набор точек получайте с помощью преобразования Бокса - Мюллера.
 При фиксированном N, количестве вершин графа, несколько раз запустите оценку качества приближения.
 Вычислите среднее значение и среднеквадратичное отклонение качества приближения для данного N.
 Запустите данный эксперимент для всех N в некотором диапазоне, например, [2, 10].
 Автоматизируйте запуск экспериментов.
 В решении требуется разумно разделить код на файлы. Каждому классу - свой заголовочный файл и файл с реализацией.

*Вариант 2.* Для построения минимального остовного дерева используйте алгоритм Прима.

